<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8">
        <title>Canvas Test</title>
    </head>

    <body onload="resetAll();">
        <canvas id="chart" width="500px" height="100px"></canvas>
          <script type="text/javascript">
              /*<![CDATA[*/

              var debug = 1;

              var width = 20;
              var vertical_scale = 5;

              var num_animation_steps = 40;
              var animation_step_num = 0;

              var last_selected = 0;

              var animator = null;

              var swap_a = null;
              var swap_b = null;

              var scan_a = null;
              var scan_b = null;
              var scan_c = null;

              var animator_is_playing = 0;

              var sorted_indices = Array();
              var animation_steps = Array();

              var ctx = document.getElementById('chart').getContext('2d');
              var array = Array();

              function resetArray() {
                  array = Array(10, 5, 11, 18, 2, 7, 8, 20, 10, 1, 3, 8, 16, 3, 12, 5, 7, 8, 17, 10);
                  drawAllExcept();
              }

              function drawIndex(index, style, swap_index) {
                  if (style && style == "hidden") {
                      ctx.fillStyle = '#fff';
                      ctx.strokeStyle = '#fff';
                  }
                  else if (style && style == "active") {
                      ctx.fillStyle = '#f00';
                      ctx.strokeStyle = '#ccc';
                  }
                  else if (style && style == "scan") {
                      ctx.fillStyle = '#999';
                      ctx.strokeStyle = '#ccc';
                  }
                  else if (style && style == "scan_selected") {
                      ctx.fillStyle = '#666';
                      ctx.strokeStyle = '#ccc';
                  }
                  else {
                      if (contains(sorted_indices, index)) {
                          ctx.fillStyle = '#999';
                          ctx.strokeStyle = '#ccc';
                      }
                      else {
                          ctx.fillStyle = '#08f';
                          ctx.strokeStyle = '#ccc';
                      }
                  }
                  ctx.beginPath();
                  var x = index * width;
                  var val = array[index] * vertical_scale;
                  if (style && style == "scan" || style == "scan_selected") {
                      val = 6;
                  }
                  var y = 100-val;

                  if (swap_index !== undefined) {
                      var distance = (index - swap_index) * width;
                      distance = parseInt((distance / num_animation_steps) * animation_step_num);
                      x -= distance;
                  }

                  ctx.rect(x, y, width, val);
                  ctx.fill();
                  ctx.stroke();
              }

              function drawAllExcept (do_not_draw_array) {
                  ctx.fillStyle = '#fff';
                  ctx.rect(0, 0, 500, 100);
                  ctx.fill();
                  for (var index=0; index < array.length; index++) {
                      if (! (do_not_draw_array && contains(do_not_draw_array, index)))
                          drawIndex(index);
                      else
                          drawIndex(index, "hidden");
                  }
              }


              function start_animation() {

                  if (debug)
                      document.getElementById("debug").innerHTML = animation_steps;

                  if (animator_is_playing != 1) {
                      window.clearInterval(animator);
                      animator = setInterval("start_animation()", 100);
                      return;
                  }

                  var step = animation_steps.shift();

                  if (step && step[0] == "swap" && animation_step_num == 0) {
                      swap_a = step[1];
                      swap_b = step[2];
                      window.clearInterval(animator);
                      animator = setInterval("swap()", 10);
                      animator_is_playing = 1;
                      return;
                  }

                  if (step && step[0] == "scan_from" && animation_step_num == 0) {
                      scan_a = step[1];
                      scan_b = step[2];
                      scan_c = step[3];
                      window.clearInterval(animator);
                      animator = setInterval("scan()", 100);
                      animator_is_playing = 1;
                      return;
                  }

                  if (step && step[0] == "add_to_sorted") {
                      sorted_indices.push(step[1]);
                      drawAllExcept();
                      start_animation();
                      return;
                  }

                  //no more animation steps
                  document.getElementById("number_of_comparisons").innerHTML = "" + number_of_comparisons;
                  document.getElementById("number_of_swaps").innerHTML = "" + number_of_swaps;
                  animator_is_playing = 0;

              }

              function swap() {
                  animation_step_num++;
                  drawAllExcept([swap_a, swap_b]);
                  drawIndex(swap_a, "active", swap_b);
                  drawIndex(swap_b, "active", swap_a);

                  if (animation_step_num == num_animation_steps - 1) {
                      window.clearInterval(animator);
                      doSwap(swap_b, swap_a, 1);
                      animation_step_num = 0;
                      drawAllExcept();
                      start_animation();
                  }
              }

              function scan() {
                  animation_step_num++;

                  var current_index = scan_a + animation_step_num - 1;
                  var number_of_steps_in_scan = scan_b - scan_a;
                  var number_of_elements = scan_c - scan_a;

                  if (number_of_steps_in_scan < 1 || animation_step_num > number_of_elements) {
                      window.clearInterval(animator);
                      animation_step_num = 0;
                      last_selected = 0;
                      start_animation();
                      return;
                  }

                  drawAllExcept();
                  if (animation_step_num == 1 || array[current_index] < array[last_selected]) {
                      last_selected = current_index;
                      drawIndex(current_index, "scan_selected");
                  }
                  else {
                      drawIndex(last_selected, "scan_selected");
                  }
                  drawIndex(scan_a + (animation_step_num - 1), "scan");

              }

              function contains(a, obj) {
                  var i = a.length;
                  while (i--) {
                      if (a[i] === obj) {
                          return true;
                      }
                  }
                  return false;
              }

              function resetAll() {
                  document.getElementById("number_of_comparisons").innerHTML = "";
                  document.getElementById("number_of_swaps").innerHTML = "";
                  number_of_comparisons = 0;
                  number_of_swaps = 0;

                  sorted_indices = Array();
                  resetArray();
                  animation_steps = Array();
              }

              function doSort(type) {
                  resetAll();
                  if (type == "selection") {
                      selectionSort();
                  }
                  else if (type == "shell") {
                      shellSort();
                  }
                  else if (type == "bubble") {
                      bubbleSort();
                  }
                  resetArray();
                  animator_is_playing = 1;
                  start_animation();
              }

              function doSwap(a, b, do_not_push) {
                  var x = array[b];
                  array[b] = array[a];
                  array[a] = x;
                  if (! do_not_push) {
                      animation_steps.push(Array("swap", a, b));
                      number_of_swaps++;
                  }
              }

                function bubbleSort() {
                  var i;             // The initial index for the bubbling scan.
                  var j;             // The running index for the bubbling scan.
                  for ( i = array.length; i; i-- ) {
                      for ( j = 1; j <= i; j++ ) {
                          number_of_comparisons++;
                          // Swap if needed.
                          if ( array[ j - 1 ] > array[ j ] ) {
                              doSwap(j, j - 1);
                          }
                      }
                      animation_steps.push(["add_to_sorted", i]);
                  }
                }

              function selectionSort() {
                  var i; // The starting index of the minimum finding scan
                  var j; // The running index of the minimum finding scan

                  for (i = 0; i < array.length; i++) {
                      var m = i; // The index of the minimum element
                      var x = array[i]; // The minimum value

                      for (j = i + 1; j < array.length; j++) {
                          if (array[j] < x) {
                              number_of_comparisons++;
                              m = j;
                              x = array[j];
                          }
                      }

                      animation_steps.push(["scan_from", i, m, array.length]);

                      if (m != i) {
                          doSwap(m, i);
                      }

                      animation_steps.push(["add_to_sorted", i]);
                  }

              }

              function shellSort() {
                  var i;              // The initial index for the bubbling scan.
                  var j;              // The running index for the bubbling scan.
                  var shell;          // The shell size.

                  for ( shell = 1; shell < array.length; shell = 2 * shell + 1 ) {
                      // Do nothing here, just let the shell grow.
                  }

                  while (shell > 1) {
                      shell = parseInt( ( shell - 1 ) / 2 );
                      for ( i = shell; i < array.length; i++ ) {
                          for ( j = i - shell;
                                j >= 0 && ++number_of_comparisons && array[j] > array[j + shell];
                                j -= shell ) {
                              doSwap(j, j + shell);
                          }
                      }
                  }
                }


              /*]]>*/
        </script>
        <button onclick="resetAll();">reset</button>
        <button onclick="animator_is_playing=0;">pause</button>
        <button onclick="animator_is_playing=1;">play</button>
        <button onclick="doSort('selection');">selectionSort</button>
        <button onclick="doSort('bubble');">bubbleSort</button>
        <button onclick="doSort('shell');">shellSort</button>
        <div>
            Number of comparisons: <span id="number_of_comparisons"></span><br>
            Number of swaps: <span id="number_of_swaps"></span>
        </div>
        <div id="debug">
        </div>
    </body>
</html>
